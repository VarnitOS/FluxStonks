"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/stock/page",{

/***/ "(app-pages-browser)/./components/PixelCard.tsx":
/*!**********************************!*\
  !*** ./components/PixelCard.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PixelCard)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nclass Pixel {\n    getRandomValue(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    draw() {\n        const centerOffset = this.maxSizeInteger * 0.5 - this.size * 0.5;\n        this.ctx.fillStyle = this.color;\n        this.ctx.fillRect(this.x + centerOffset, this.y + centerOffset, this.size, this.size);\n    }\n    appear() {\n        this.isIdle = false;\n        if (this.counter <= this.delay) {\n            this.counter += this.counterStep;\n            return;\n        }\n        if (this.size >= this.maxSize) {\n            this.isShimmer = true;\n        }\n        if (this.isShimmer) {\n            this.shimmer();\n        } else {\n            this.size += this.sizeStep;\n        }\n        this.draw();\n    }\n    disappear() {\n        this.isShimmer = false;\n        this.counter = 0;\n        if (this.size <= 0) {\n            this.isIdle = true;\n            return;\n        } else {\n            this.size -= 0.1;\n        }\n        this.draw();\n    }\n    shimmer() {\n        if (this.size >= this.maxSize) {\n            this.isReverse = true;\n        } else if (this.size <= this.minSize) {\n            this.isReverse = false;\n        }\n        if (this.isReverse) {\n            this.size -= this.speed;\n        } else {\n            this.size += this.speed;\n        }\n    }\n    constructor(canvas, context, x, y, color, speed, delay){\n        this.width = canvas.width;\n        this.height = canvas.height;\n        this.ctx = context;\n        this.x = x;\n        this.y = y;\n        this.color = color;\n        this.speed = this.getRandomValue(0.1, 0.9) * speed;\n        this.size = 0;\n        this.sizeStep = Math.random() * 0.4;\n        this.minSize = 0.5;\n        this.maxSizeInteger = 2;\n        this.maxSize = this.getRandomValue(this.minSize, this.maxSizeInteger);\n        this.delay = delay;\n        this.counter = 0;\n        this.counterStep = Math.random() * 4 + (this.width + this.height) * 0.01;\n        this.isIdle = false;\n        this.isReverse = false;\n        this.isShimmer = false;\n    }\n}\nfunction getEffectiveSpeed(value, reducedMotion) {\n    const min = 0;\n    const max = 100;\n    const throttle = 0.001;\n    const parsed = parseInt(value, 10);\n    if (parsed <= min || reducedMotion) {\n        return min;\n    } else if (parsed >= max) {\n        return max * throttle;\n    } else {\n        return parsed * throttle;\n    }\n}\n/**\n *  You can change/expand these as you like.\n */ const VARIANTS = {\n    default: {\n        activeColor: null,\n        gap: 5,\n        speed: 35,\n        colors: \"#f8fafc,#f1f5f9,#cbd5e1\",\n        noFocus: false\n    },\n    blue: {\n        activeColor: \"#e0f2fe\",\n        gap: 10,\n        speed: 25,\n        colors: \"#e0f2fe,#7dd3fc,#0ea5e9\",\n        noFocus: false\n    },\n    yellow: {\n        activeColor: \"#fef08a\",\n        gap: 3,\n        speed: 20,\n        colors: \"#fef08a,#fde047,#eab308\",\n        noFocus: false\n    },\n    pink: {\n        activeColor: \"#fecdd3\",\n        gap: 6,\n        speed: 80,\n        colors: \"#fecdd3,#fda4af,#e11d48\",\n        noFocus: true\n    }\n};\nfunction PixelCard(param) {\n    let { variant = \"default\", gap, speed, colors, noFocus, className = \"\", children } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const pixelsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const animationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const timePreviousRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(performance.now());\n    const reducedMotion = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches).current;\n    const variantCfg = VARIANTS[variant] || VARIANTS.default;\n    const finalGap = gap !== null && gap !== void 0 ? gap : variantCfg.gap;\n    const finalSpeed = speed !== null && speed !== void 0 ? speed : variantCfg.speed;\n    const finalColors = colors !== null && colors !== void 0 ? colors : variantCfg.colors;\n    const finalNoFocus = noFocus !== null && noFocus !== void 0 ? noFocus : variantCfg.noFocus;\n    const initPixels = ()=>{\n        if (!containerRef.current || !canvasRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const width = Math.floor(rect.width);\n        const height = Math.floor(rect.height);\n        const ctx = canvasRef.current.getContext(\"2d\");\n        canvasRef.current.width = width;\n        canvasRef.current.height = height;\n        canvasRef.current.style.width = \"\".concat(width, \"px\");\n        canvasRef.current.style.height = \"\".concat(height, \"px\");\n        const colorsArray = finalColors.split(\",\");\n        const pxs = [];\n        for(let x = 0; x < width; x += parseInt(finalGap.toString(), 10)){\n            for(let y = 0; y < height; y += parseInt(finalGap.toString(), 10)){\n                const color = colorsArray[Math.floor(Math.random() * colorsArray.length)];\n                const dx = x - width / 2;\n                const dy = y - height / 2;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const delay = reducedMotion ? 0 : distance;\n                if (!ctx) return;\n                pxs.push(new Pixel(canvasRef.current, ctx, x, y, color, getEffectiveSpeed(finalSpeed, reducedMotion), delay));\n            }\n        }\n        pixelsRef.current = pxs;\n    };\n    const doAnimate = (fnName)=>{\n        var _canvasRef_current;\n        animationRef.current = requestAnimationFrame(()=>doAnimate(fnName));\n        const timeNow = performance.now();\n        const timePassed = timeNow - timePreviousRef.current;\n        const timeInterval = 1000 / 60; // ~60 FPS\n        if (timePassed < timeInterval) return;\n        timePreviousRef.current = timeNow - timePassed % timeInterval;\n        const ctx = (_canvasRef_current = canvasRef.current) === null || _canvasRef_current === void 0 ? void 0 : _canvasRef_current.getContext(\"2d\");\n        if (!ctx || !canvasRef.current) return;\n        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n        let allIdle = true;\n        for(let i = 0; i < pixelsRef.current.length; i++){\n            const pixel = pixelsRef.current[i];\n            // @ts-ignore\n            pixel[fnName]();\n            if (!pixel.isIdle) {\n                allIdle = false;\n            }\n        }\n        if (allIdle) {\n            cancelAnimationFrame(animationRef.current);\n        }\n    };\n    const handleAnimation = (name)=>{\n        cancelAnimationFrame(animationRef.current);\n        animationRef.current = requestAnimationFrame(()=>doAnimate(name));\n    };\n    const onMouseEnter = ()=>handleAnimation(\"appear\");\n    const onMouseLeave = ()=>handleAnimation(\"disappear\");\n    const onFocus = (e)=>{\n        if (e.currentTarget.contains(e.relatedTarget)) return;\n        handleAnimation(\"appear\");\n    };\n    const onBlur = (e)=>{\n        if (e.currentTarget.contains(e.relatedTarget)) return;\n        handleAnimation(\"disappear\");\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"PixelCard.useEffect\": ()=>{\n            initPixels();\n            const observer = new ResizeObserver({\n                \"PixelCard.useEffect\": ()=>{\n                    initPixels();\n                }\n            }[\"PixelCard.useEffect\"]);\n            if (containerRef.current) {\n                observer.observe(containerRef.current);\n            }\n            return ({\n                \"PixelCard.useEffect\": ()=>{\n                    observer.disconnect();\n                    cancelAnimationFrame(animationRef.current);\n                }\n            })[\"PixelCard.useEffect\"];\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"PixelCard.useEffect\"], [\n        finalGap,\n        finalSpeed,\n        finalColors,\n        finalNoFocus\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"h-[400px] w-[300px] relative overflow-hidden grid place-items-center aspect-[4/5] border border-[#27272a] rounded-[25px] isolate transition-colors duration-200 ease-[cubic-bezier(0.5,1,0.89,1)] select-none \".concat(className),\n        onMouseEnter: onMouseEnter,\n        onMouseLeave: onMouseLeave,\n        onFocus: finalNoFocus ? undefined : onFocus,\n        onBlur: finalNoFocus ? undefined : onBlur,\n        tabIndex: finalNoFocus ? -1 : 0,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                className: \"w-full h-full block\",\n                ref: canvasRef\n            }, void 0, false, {\n                fileName: \"/Users/varriza/Documents/PROJECTS/FULL-BASE/backend_python/FluxCore/frontend/components/PixelCard.tsx\",\n                lineNumber: 307,\n                columnNumber: 13\n            }, this),\n            children\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/varriza/Documents/PROJECTS/FULL-BASE/backend_python/FluxCore/frontend/components/PixelCard.tsx\",\n        lineNumber: 296,\n        columnNumber: 9\n    }, this);\n}\n_s(PixelCard, \"1g2TH4O5gnWsyabujaCI4QYsjeI=\");\n_c = PixelCard;\nvar _c;\n$RefreshReg$(_c, \"PixelCard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvUGl4ZWxDYXJkLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFFL0MsTUFBTUc7SUEwQ0ZDLGVBQWVDLEdBQVcsRUFBRUMsR0FBVyxFQUFFO1FBQ3JDLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtJQUN6QztJQUVBSSxPQUFPO1FBQ0gsTUFBTUMsZUFBZSxJQUFJLENBQUNDLGNBQWMsR0FBRyxNQUFNLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQzdELElBQUksQ0FBQ0MsR0FBRyxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDQyxLQUFLO1FBQy9CLElBQUksQ0FBQ0YsR0FBRyxDQUFDRyxRQUFRLENBQ2IsSUFBSSxDQUFDQyxDQUFDLEdBQUdQLGNBQ1QsSUFBSSxDQUFDUSxDQUFDLEdBQUdSLGNBQ1QsSUFBSSxDQUFDRSxJQUFJLEVBQ1QsSUFBSSxDQUFDQSxJQUFJO0lBRWpCO0lBRUFPLFNBQVM7UUFDTCxJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUksSUFBSSxDQUFDQyxLQUFLLEVBQUU7WUFDNUIsSUFBSSxDQUFDRCxPQUFPLElBQUksSUFBSSxDQUFDRSxXQUFXO1lBQ2hDO1FBQ0o7UUFDQSxJQUFJLElBQUksQ0FBQ1gsSUFBSSxJQUFJLElBQUksQ0FBQ1ksT0FBTyxFQUFFO1lBQzNCLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ3JCO1FBQ0EsSUFBSSxJQUFJLENBQUNBLFNBQVMsRUFBRTtZQUNoQixJQUFJLENBQUNDLE9BQU87UUFDaEIsT0FBTztZQUNILElBQUksQ0FBQ2QsSUFBSSxJQUFJLElBQUksQ0FBQ2UsUUFBUTtRQUM5QjtRQUNBLElBQUksQ0FBQ2xCLElBQUk7SUFDYjtJQUVBbUIsWUFBWTtRQUNSLElBQUksQ0FBQ0gsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0osT0FBTyxHQUFHO1FBQ2Ys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USxDQUFDRixFQUFFRyxhQUFhLEdBQUc7UUFDL0NSLGdCQUFnQjtJQUNwQjtJQUNBLE1BQU1TLFNBQWtELENBQUNKO1FBQ3JELElBQUlBLEVBQUVDLGFBQWEsQ0FBQ0MsUUFBUSxDQUFDRixFQUFFRyxhQUFhLEdBQUc7UUFDL0NSLGdCQUFnQjtJQUNwQjtJQUVBbEcsZ0RBQVNBOytCQUFDO1lBQ051RTtZQUNBLE1BQU1xQyxXQUFXLElBQUlDO3VDQUFlO29CQUNoQ3RDO2dCQUNKOztZQUNBLElBQUloQixhQUFhVSxPQUFPLEVBQUU7Z0JBQ3RCMkMsU0FBU0UsT0FBTyxDQUFDdkQsYUFBYVUsT0FBTztZQUN6QztZQUNBO3VDQUFPO29CQUNIMkMsU0FBU0csVUFBVTtvQkFDbkJkLHFCQUFxQnZDLGFBQWFPLE9BQU87Z0JBQzdDOztRQUNBLHVEQUF1RDtRQUMzRDs4QkFBRztRQUFDRTtRQUFVQztRQUFZQztRQUFhQztLQUFhO0lBRXBELHFCQUNJLDhEQUFDMEM7UUFDR0MsS0FBSzFEO1FBQ0xGLFdBQVcsaU5BQTJOLE9BQVZBO1FBRTVOK0MsY0FBY0E7UUFDZEMsY0FBY0E7UUFFZEMsU0FBU2hDLGVBQWU0QyxZQUFZWjtRQUNwQ0ssUUFBUXJDLGVBQWU0QyxZQUFZUDtRQUNuQ1EsVUFBVTdDLGVBQWUsQ0FBQyxJQUFJOzswQkFFOUIsOERBQUN0QztnQkFDR3FCLFdBQVU7Z0JBQ1Y0RCxLQUFLekQ7Ozs7OztZQUVSRjs7Ozs7OztBQUdiO0dBaEp3Qkg7S0FBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92YXJyaXphL0RvY3VtZW50cy9QUk9KRUNUUy9GVUxMLUJBU0UvYmFja2VuZF9weXRob24vRmx1eENvcmUvZnJvbnRlbmQvY29tcG9uZW50cy9QaXhlbENhcmQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwge3VzZUVmZmVjdCwgdXNlUmVmfSBmcm9tIFwicmVhY3RcIjtcblxuY2xhc3MgUGl4ZWwge1xuXG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGNvbG9yOiBzdHJpbmc7XG4gICAgc3BlZWQ6IG51bWJlcjtcbiAgICBzaXplOiBudW1iZXI7XG4gICAgc2l6ZVN0ZXA6IG51bWJlcjtcbiAgICBtaW5TaXplOiBudW1iZXI7XG4gICAgbWF4U2l6ZUludGVnZXI6IG51bWJlcjtcbiAgICBtYXhTaXplOiBudW1iZXI7XG4gICAgZGVsYXk6IG51bWJlcjtcbiAgICBjb3VudGVyOiBudW1iZXI7XG4gICAgY291bnRlclN0ZXA6IG51bWJlcjtcbiAgICBpc0lkbGU6IGJvb2xlYW47XG4gICAgaXNSZXZlcnNlOiBib29sZWFuO1xuICAgIGlzU2hpbW1lcjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGNvbnRleHQ6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvbG9yOiBzdHJpbmcsIHNwZWVkOiBudW1iZXIsIGRlbGF5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICAgICAgdGhpcy5zcGVlZCA9IHRoaXMuZ2V0UmFuZG9tVmFsdWUoMC4xLCAwLjkpICogc3BlZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZVN0ZXAgPSBNYXRoLnJhbmRvbSgpICogMC40O1xuICAgICAgICB0aGlzLm1pblNpemUgPSAwLjU7XG4gICAgICAgIHRoaXMubWF4U2l6ZUludGVnZXIgPSAyO1xuICAgICAgICB0aGlzLm1heFNpemUgPSB0aGlzLmdldFJhbmRvbVZhbHVlKHRoaXMubWluU2l6ZSwgdGhpcy5tYXhTaXplSW50ZWdlcik7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5jb3VudGVyU3RlcCA9IE1hdGgucmFuZG9tKCkgKiA0ICsgKHRoaXMud2lkdGggKyB0aGlzLmhlaWdodCkgKiAwLjAxO1xuICAgICAgICB0aGlzLmlzSWRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2hpbW1lciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldFJhbmRvbVZhbHVlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuICAgIH1cblxuICAgIGRyYXcoKSB7XG4gICAgICAgIGNvbnN0IGNlbnRlck9mZnNldCA9IHRoaXMubWF4U2l6ZUludGVnZXIgKiAwLjUgLSB0aGlzLnNpemUgKiAwLjU7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuY29sb3I7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgdGhpcy54ICsgY2VudGVyT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy55ICsgY2VudGVyT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5zaXplLFxuICAgICAgICAgICAgdGhpcy5zaXplXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgYXBwZWFyKCkge1xuICAgICAgICB0aGlzLmlzSWRsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jb3VudGVyIDw9IHRoaXMuZGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRlciArPSB0aGlzLmNvdW50ZXJTdGVwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpemUgPj0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2hpbW1lciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaGltbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoaW1tZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSArPSB0aGlzLnNpemVTdGVwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgIH1cblxuICAgIGRpc2FwcGVhcigpIHtcbiAgICAgICAgdGhpcy5pc1NoaW1tZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzSWRsZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNpemUgLT0gMC4xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhdygpO1xuICAgIH1cblxuICAgIHNoaW1tZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPj0gdGhpcy5tYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zaXplIDw9IHRoaXMubWluU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5pc1JldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtPSB0aGlzLnNwZWVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaXplICs9IHRoaXMuc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZVNwZWVkKHZhbHVlOiBhbnksIHJlZHVjZWRNb3Rpb246IGFueSkge1xuICAgIGNvbnN0IG1pbiA9IDA7XG4gICAgY29uc3QgbWF4ID0gMTAwO1xuICAgIGNvbnN0IHRocm90dGxlID0gMC4wMDE7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcblxuICAgIGlmIChwYXJzZWQgPD0gbWluIHx8IHJlZHVjZWRNb3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9IGVsc2UgaWYgKHBhcnNlZCA+PSBtYXgpIHtcbiAgICAgICAgcmV0dXJuIG1heCAqIHRocm90dGxlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQgKiB0aHJvdHRsZTtcbiAgICB9XG59XG5cbi8qKlxuICogIFlvdSBjYW4gY2hhbmdlL2V4cGFuZCB0aGVzZSBhcyB5b3UgbGlrZS5cbiAqL1xuY29uc3QgVkFSSUFOVFMgPSB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgICBhY3RpdmVDb2xvcjogbnVsbCxcbiAgICAgICAgZ2FwOiA1LFxuICAgICAgICBzcGVlZDogMzUsXG4gICAgICAgIGNvbG9yczogXCIjZjhmYWZjLCNmMWY1ZjksI2NiZDVlMVwiLFxuICAgICAgICBub0ZvY3VzOiBmYWxzZVxuICAgIH0sXG4gICAgYmx1ZToge1xuICAgICAgICBhY3RpdmVDb2xvcjogXCIjZTBmMmZlXCIsXG4gICAgICAgIGdhcDogMTAsXG4gICAgICAgIHNwZWVkOiAyNSxcbiAgICAgICAgY29sb3JzOiBcIiNlMGYyZmUsIzdkZDNmYywjMGVhNWU5XCIsXG4gICAgICAgIG5vRm9jdXM6IGZhbHNlXG4gICAgfSxcbiAgICB5ZWxsb3c6IHtcbiAgICAgICAgYWN0aXZlQ29sb3I6IFwiI2ZlZjA4YVwiLFxuICAgICAgICBnYXA6IDMsXG4gICAgICAgIHNwZWVkOiAyMCxcbiAgICAgICAgY29sb3JzOiBcIiNmZWYwOGEsI2ZkZTA0NywjZWFiMzA4XCIsXG4gICAgICAgIG5vRm9jdXM6IGZhbHNlXG4gICAgfSxcbiAgICBwaW5rOiB7XG4gICAgICAgIGFjdGl2ZUNvbG9yOiBcIiNmZWNkZDNcIixcbiAgICAgICAgZ2FwOiA2LFxuICAgICAgICBzcGVlZDogODAsXG4gICAgICAgIGNvbG9yczogXCIjZmVjZGQzLCNmZGE0YWYsI2UxMWQ0OFwiLFxuICAgICAgICBub0ZvY3VzOiB0cnVlXG4gICAgfVxufTtcblxuaW50ZXJmYWNlIFBpeGVsQ2FyZFByb3BzIHtcbiAgICB2YXJpYW50PzogXCJkZWZhdWx0XCIgfCBcImJsdWVcIiB8IFwieWVsbG93XCIgfCBcInBpbmtcIjtcbiAgICBnYXA/OiBudW1iZXI7XG4gICAgc3BlZWQ/OiBudW1iZXI7XG4gICAgY29sb3JzPzogc3RyaW5nO1xuICAgIG5vRm9jdXM/OiBib29sZWFuO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufVxuXG5pbnRlcmZhY2UgVmFyaWFudENvbmZpZyB7XG4gICAgYWN0aXZlQ29sb3I6IHN0cmluZyB8IG51bGxcbiAgICBnYXA6IG51bWJlclxuICAgIHNwZWVkOiBudW1iZXJcbiAgICBjb2xvcnM6IHN0cmluZ1xuICAgIG5vRm9jdXM6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUGl4ZWxDYXJkKHtcbiAgICB2YXJpYW50ID0gXCJkZWZhdWx0XCIsXG4gICAgZ2FwLFxuICAgIHNwZWVkLFxuICAgIGNvbG9ycyxcbiAgICBub0ZvY3VzLFxuICAgIGNsYXNzTmFtZSA9IFwiXCIsXG4gICAgY2hpbGRyZW5cbiB9OiBQaXhlbENhcmRQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG5cbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgcGl4ZWxzUmVmID0gdXNlUmVmPFBpeGVsW10+KFtdKTtcbiAgICBjb25zdCBhbmltYXRpb25SZWYgPSB1c2VSZWY8YW55PihudWxsKTtcbiAgICBjb25zdCB0aW1lUHJldmlvdXNSZWYgPSB1c2VSZWYocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIGNvbnN0IHJlZHVjZWRNb3Rpb24gPSB1c2VSZWYoXG4gICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlc1xuICAgICkuY3VycmVudDtcblxuICAgIGNvbnN0IHZhcmlhbnRDZmc6IFZhcmlhbnRDb25maWcgPSBWQVJJQU5UU1t2YXJpYW50XSB8fCBWQVJJQU5UUy5kZWZhdWx0O1xuICAgIGNvbnN0IGZpbmFsR2FwID0gZ2FwID8/IHZhcmlhbnRDZmcuZ2FwO1xuICAgIGNvbnN0IGZpbmFsU3BlZWQgPSBzcGVlZCA/PyB2YXJpYW50Q2ZnLnNwZWVkO1xuICAgIGNvbnN0IGZpbmFsQ29sb3JzID0gY29sb3JzID8/IHZhcmlhbnRDZmcuY29sb3JzO1xuICAgIGNvbnN0IGZpbmFsTm9Gb2N1cyA9IG5vRm9jdXMgPz8gdmFyaWFudENmZy5ub0ZvY3VzO1xuXG4gICAgY29uc3QgaW5pdFBpeGVscyA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFjb250YWluZXJSZWYuY3VycmVudCB8fCAhY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5mbG9vcihyZWN0LndpZHRoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5mbG9vcihyZWN0LmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50LmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuXG4gICAgICAgIGNvbnN0IGNvbG9yc0FycmF5ID0gZmluYWxDb2xvcnMuc3BsaXQoXCIsXCIpO1xuICAgICAgICBjb25zdCBweHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCArPSBwYXJzZUludChmaW5hbEdhcC50b1N0cmluZygpLCAxMCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IHBhcnNlSW50KGZpbmFsR2FwLnRvU3RyaW5nKCksIDEwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID1cbiAgICAgICAgICAgICAgICAgICAgY29sb3JzQXJyYXlbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29sb3JzQXJyYXkubGVuZ3RoKV07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkeCA9IHggLSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgZHkgPSB5IC0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSByZWR1Y2VkTW90aW9uID8gMCA6IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmKCFjdHgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBweHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgbmV3IFBpeGVsKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0RWZmZWN0aXZlU3BlZWQoZmluYWxTcGVlZCwgcmVkdWNlZE1vdGlvbiksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwaXhlbHNSZWYuY3VycmVudCA9IHB4cztcbiAgICB9O1xuXG4gICAgY29uc3QgZG9BbmltYXRlID0gKGZuTmFtZToga2V5b2YgUGl4ZWwpID0+IHtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZG9BbmltYXRlKGZuTmFtZSkpO1xuICAgICAgICBjb25zdCB0aW1lTm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IHRpbWVQYXNzZWQgPSB0aW1lTm93IC0gdGltZVByZXZpb3VzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHRpbWVJbnRlcnZhbCA9IDEwMDAgLyA2MDsgLy8gfjYwIEZQU1xuXG4gICAgICAgIGlmICh0aW1lUGFzc2VkIDwgdGltZUludGVydmFsKSByZXR1cm47XG4gICAgICAgIHRpbWVQcmV2aW91c1JlZi5jdXJyZW50ID0gdGltZU5vdyAtICh0aW1lUGFzc2VkICUgdGltZUludGVydmFsKTtcblxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXNSZWYuY3VycmVudD8uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoIWN0eCB8fCAhY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoLCBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQpO1xuXG4gICAgICAgIGxldCBhbGxJZGxlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbHNSZWYuY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGl4ZWwgPSBwaXhlbHNSZWYuY3VycmVudFtpXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHBpeGVsW2ZuTmFtZV0oKTtcbiAgICAgICAgICAgIGlmICghcGl4ZWwuaXNJZGxlKSB7XG4gICAgICAgICAgICAgICAgYWxsSWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxJZGxlKSB7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25SZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlQW5pbWF0aW9uID0gKG5hbWU6IGtleW9mIFBpeGVsKSA9PiB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcbiAgICAgICAgYW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZG9BbmltYXRlKG5hbWUpKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZUVudGVyID0gKCkgPT4gaGFuZGxlQW5pbWF0aW9uKFwiYXBwZWFyXCIpO1xuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9ICgpID0+IGhhbmRsZUFuaW1hdGlvbihcImRpc2FwcGVhclwiKTtcbiAgICBjb25zdCBvbkZvY3VzOiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4gPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICAgICAgaGFuZGxlQW5pbWF0aW9uKFwiYXBwZWFyXCIpO1xuICAgIH07XG4gICAgY29uc3Qgb25CbHVyOiBSZWFjdC5Gb2N1c0V2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4gPSAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpIHJldHVybjtcbiAgICAgICAgaGFuZGxlQW5pbWF0aW9uKFwiZGlzYXBwZWFyXCIpO1xuICAgIH07XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpbml0UGl4ZWxzKCk7XG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGluaXRQaXhlbHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJlZi5jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtmaW5hbEdhcCwgZmluYWxTcGVlZCwgZmluYWxDb2xvcnMsIGZpbmFsTm9Gb2N1c10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BoLVs0MDBweF0gdy1bMzAwcHhdIHJlbGF0aXZlIG92ZXJmbG93LWhpZGRlbiBncmlkIHBsYWNlLWl0ZW1zLWNlbnRlciBhc3BlY3QtWzQvNV0gYm9yZGVyIGJvcmRlci1bIzI3MjcyYV0gcm91bmRlZC1bMjVweF0gaXNvbGF0ZSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1bY3ViaWMtYmV6aWVyKDAuNSwxLDAuODksMSldIHNlbGVjdC1ub25lICR7Y2xhc3NOYW1lfWB9XG5cbiAgICAgICAgICAgIG9uTW91c2VFbnRlcj17b25Nb3VzZUVudGVyfVxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXtvbk1vdXNlTGVhdmV9XG5cbiAgICAgICAgICAgIG9uRm9jdXM9e2ZpbmFsTm9Gb2N1cyA/IHVuZGVmaW5lZCA6IG9uRm9jdXN9XG4gICAgICAgICAgICBvbkJsdXI9e2ZpbmFsTm9Gb2N1cyA/IHVuZGVmaW5lZCA6IG9uQmx1cn1cbiAgICAgICAgICAgIHRhYkluZGV4PXtmaW5hbE5vRm9jdXMgPyAtMSA6IDB9XG4gICAgICAgID5cbiAgICAgICAgICAgIDxjYW52YXNcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGJsb2NrXCJcbiAgICAgICAgICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJQaXhlbCIsImdldFJhbmRvbVZhbHVlIiwibWluIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsImRyYXciLCJjZW50ZXJPZmZzZXQiLCJtYXhTaXplSW50ZWdlciIsInNpemUiLCJjdHgiLCJmaWxsU3R5bGUiLCJjb2xvciIsImZpbGxSZWN0IiwieCIsInkiLCJhcHBlYXIiLCJpc0lkbGUiLCJjb3VudGVyIiwiZGVsYXkiLCJjb3VudGVyU3RlcCIsIm1heFNpemUiLCJpc1NoaW1tZXIiLCJzaGltbWVyIiwic2l6ZVN0ZXAiLCJkaXNhcHBlYXIiLCJpc1JldmVyc2UiLCJtaW5TaXplIiwic3BlZWQiLCJjb25zdHJ1Y3RvciIsImNhbnZhcyIsImNvbnRleHQiLCJ3aWR0aCIsImhlaWdodCIsImdldEVmZmVjdGl2ZVNwZWVkIiwidmFsdWUiLCJyZWR1Y2VkTW90aW9uIiwidGhyb3R0bGUiLCJwYXJzZWQiLCJwYXJzZUludCIsIlZBUklBTlRTIiwiZGVmYXVsdCIsImFjdGl2ZUNvbG9yIiwiZ2FwIiwiY29sb3JzIiwibm9Gb2N1cyIsImJsdWUiLCJ5ZWxsb3ciLCJwaW5rIiwiUGl4ZWxDYXJkIiwidmFyaWFudCIsImNsYXNzTmFtZSIsImNoaWxkcmVuIiwiY29udGFpbmVyUmVmIiwiY2FudmFzUmVmIiwicGl4ZWxzUmVmIiwiYW5pbWF0aW9uUmVmIiwidGltZVByZXZpb3VzUmVmIiwicGVyZm9ybWFuY2UiLCJub3ciLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImN1cnJlbnQiLCJ2YXJpYW50Q2ZnIiwiZmluYWxHYXAiLCJmaW5hbFNwZWVkIiwiZmluYWxDb2xvcnMiLCJmaW5hbE5vRm9jdXMiLCJpbml0UGl4ZWxzIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZsb29yIiwiZ2V0Q29udGV4dCIsInN0eWxlIiwiY29sb3JzQXJyYXkiLCJzcGxpdCIsInB4cyIsInRvU3RyaW5nIiwibGVuZ3RoIiwiZHgiLCJkeSIsImRpc3RhbmNlIiwic3FydCIsInB1c2giLCJkb0FuaW1hdGUiLCJmbk5hbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0aW1lTm93IiwidGltZVBhc3NlZCIsInRpbWVJbnRlcnZhbCIsImNsZWFyUmVjdCIsImFsbElkbGUiLCJpIiwicGl4ZWwiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImhhbmRsZUFuaW1hdGlvbiIsIm5hbWUiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvbkZvY3VzIiwiZSIsImN1cnJlbnRUYXJnZXQiLCJjb250YWlucyIsInJlbGF0ZWRUYXJnZXQiLCJvbkJsdXIiLCJvYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJkaXYiLCJyZWYiLCJ1bmRlZmluZWQiLCJ0YWJJbmRleCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/PixelCard.tsx\n"));

/***/ })

});